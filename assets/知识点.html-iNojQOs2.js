import{_ as e,o as c,c as t,e as o}from"./app-M6OZmubj.js";const d="/skill-blog/img/0108.jpg",i="/skill-blog/img/0079.jpeg",a="/skill-blog/img/0083.png",l="/skill-blog/img/0131.png",r={},s=o('<h1 id="知识点" tabindex="-1"><a class="header-anchor" href="#知识点" aria-hidden="true">#</a> 知识点</h1><h2 id="jsx-element-vs-react-reactnode" tabindex="-1"><a class="header-anchor" href="#jsx-element-vs-react-reactnode" aria-hidden="true">#</a> <code>JSX.Element vs React.ReactNode</code></h2><p><img src="'+d+'" alt=""></p><h2 id="其他" tabindex="-1"><a class="header-anchor" href="#其他" aria-hidden="true">#</a> 其他</h2><ul><li>函数组件没有生命周期。</li><li>在一个受控组件中，表单数据是由<code>React</code>组件来管理的。另一种替代方案是使用非受控组件，这时表单数据将交由<code>DOM</code>节点来处理。</li><li>每个<code>JSX</code>元素都是调用<code>React.createElement()</code>的语法糖，<code>JSX</code>最终会通过<code>Babel</code>或者<code>TypeScript</code>编译为<code>React.createElement()</code>函数调用，返回称为“<code>React</code>元素”的普通<code>JavaScript</code>对象。</li><li><code>A reducer&#39;s function signature is: (state, action) =&gt; newState</code>。</li><li><img src="'+i+'" alt=""></li><li><code>const [state, setState] = useState(&lt;div&gt;123&lt;/div&gt;);</code></li><li><img src="'+a+'" alt=""></li><li>因为<code>React</code>支持跨平台，所以不同的平台有不同的<code>Renderer</code>。浏览器环境的<code>Renderer</code>是<code>ReactDOM</code>。</li><li>The only difference between useRef() and creating a <code>{ current: ... }</code> object yourself is that <strong>useRef will give you the same ref object on every render</strong>.</li><li><img src="'+l+'" alt=""></li><li><code>JSX.Element</code>继承自<code>React.ReactElement</code></li></ul>',5),n=[s];function _(h,m){return c(),t("div",null,n)}const u=e(r,[["render",_],["__file","知识点.html.vue"]]);export{u as default};
