import{_ as e,o as a,c,e as o}from"./app-M6OZmubj.js";const t={},n=o(`<h1 id="从实时通信系统看http发展" tabindex="-1"><a class="header-anchor" href="#从实时通信系统看http发展" aria-hidden="true">#</a> 从实时通信系统看<code>HTTP</code>发展</h1><p>在一些监控、<code>Web</code>在线通信、即时报价系统、在线游戏等场景中，都需要将后台发生的变化主动地、实时地传送到浏览器端，而不需要用户手动地刷新页面。为了达到这个目的，应运而生了很多方案。</p><h2 id="轮询" tabindex="-1"><a class="header-anchor" href="#轮询" aria-hidden="true">#</a> 轮询</h2><p>轮询是最简单无脑的方案。客户端定期发送<code>AJAX</code>请求，服务器端在受理请求后会立刻返回数据。这种方式保证了数据的相对实时性，具有很好的浏览器兼容性和简单性。但是，其缺点也很明显，比如，数据延迟取决于轮询频率，如果频率过高，就会产生大量无效请求，同时，服务器端的压力也会比较大，从而浪费带宽流量；如果频率过低，则数据的实时性就会较差。</p><h2 id="长轮询" tabindex="-1"><a class="header-anchor" href="#长轮询" aria-hidden="true">#</a> 长轮询</h2><p>长轮询（<code>long-polling</code>）的实现思路是：客户端通过<code>AJAX</code>发起请求，服务器端在接到请求后不马上返回，而是保持这个连接，等待数据更新。当有数据需要推送给客户端时，服务器端才将目标数据发送给客户端，返回请求。客户端收到响应后，马上再发起一个新的请求给服务器端，周而复始。</p><p>这样的长轮询能够有效减少轮询次数，而且大大降低延迟，但服务器端需要保持大量连接，会产生一定的消耗。</p><h2 id="comet-streaming" tabindex="-1"><a class="header-anchor" href="#comet-streaming" aria-hidden="true">#</a> <code>Comet streaming</code></h2><p><code>Comet streaming</code>技术又被称为<code>Forever iframe</code>，这种技术听上去更加巧妙，需要我们动态载入一个隐藏的<code>iframe</code>标签，<code>iframe</code>标签的<code>src</code>会指向请求的服务器地址。同时，客户端会准备好一个处理数据的函数，在服务器端通过<code>iframe</code>标签和客户端通信时，服务器端便会返回类似<code>script</code>标签的文本，客户端会将其解析为<code>JavaScript</code>脚本，并调用预先准备好的函数，将数据传递给<code>parent window</code>，类似<code>JSONP</code>的实现原理，代码如下。</p><div class="language-html line-numbers-mode" data-ext="html"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript"> parent<span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token string">&quot;data from server&quot;</span><span class="token punctuation">)</span> </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="ajax-multipart-streaming" tabindex="-1"><a class="header-anchor" href="#ajax-multipart-streaming" aria-hidden="true">#</a> <code>AJAX multipart streaming</code></h2><p><code>AJAX multipart streaming</code>用到了<code>HTTP 1.1</code>中的<code>multipart</code>特性：客户端发送请求，服务器端保持这个连接，利用<code>HTTP 1.1</code>的<code>chunked encoding</code>机制（分块传输编码）将数据传递给客户端，直到超时或客户端手动断开才停止传输。</p><p>这种方法属于遵循官方规范的方法，但是<code>HTTP 1.1</code>的<code>multipart</code>特性并没有更广泛地被浏览器支持。</p><h2 id="websocket" tabindex="-1"><a class="header-anchor" href="#websocket" aria-hidden="true">#</a> <code>WebSocket</code></h2><p><code>WebSocket</code>是从<code>HTML 5</code>开始提供的一种在浏览器与服务器之间进行全双工通信的网络技术。依靠这种技术可以实现客户端和服务器端的长连接，进行双向实时通信。</p><p><code>WebSocket</code>无疑是强大的，但是它也错过了浏览器为<code>HTTP</code>提供的一些服务，需要开发者在使用时自己实现，因此<code>WebSocket</code>并不能取代<code>HTTP</code>。</p>`,16),d=[n];function s(r,i){return a(),c("div",null,d)}const l=e(t,[["render",s],["__file","从实时通信系统看HTTP发展.html.vue"]]);export{l as default};
