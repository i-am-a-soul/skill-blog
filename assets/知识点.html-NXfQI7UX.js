import{_ as e,o as a,c as d,e as c}from"./app-M6OZmubj.js";const i={},r=c('<h1 id="知识点" tabindex="-1"><a class="header-anchor" href="#知识点" aria-hidden="true">#</a> 知识点</h1><h2 id="布局抖动" tabindex="-1"><a class="header-anchor" href="#布局抖动" aria-hidden="true">#</a> 布局抖动</h2><p>布局抖动是指<code>DOM</code>元素被<code>JavaScript</code>多次反复读写，导致文档多次无意义重排。我们知道浏览器很“懒”，它会合并（<code>batch</code>）当前操作，统一进行重排。可是，如果在当前操作完成前从<code>DOM</code>元素中获取值，那么就会迫使浏览器提早执行布局操作，这被称为强制同步布局。这样做对于低配置的移动设备来说，后果是不堪设想的。</p><h2 id="图片的加载" tabindex="-1"><a class="header-anchor" href="#图片的加载" aria-hidden="true">#</a> 图片的加载</h2><h3 id="关键图片" tabindex="-1"><a class="header-anchor" href="#关键图片" aria-hidden="true">#</a> 关键图片</h3><p>关键图片即用户首屏核心区域用到的图片，这部分图片我们应该尽可能早地去加载。</p><ul><li>对于体积较小的图片，使用内联加载</li><li>对于体积较大的图片，使用预加载</li></ul><h3 id="次要图片" tabindex="-1"><a class="header-anchor" href="#次要图片" aria-hidden="true">#</a> 次要图片</h3><ul><li>小体积图片：内联加载</li><li>首屏大图：常规加载</li><li>非首屏大图：异步加载</li></ul><h2 id="其他" tabindex="-1"><a class="header-anchor" href="#其他" aria-hidden="true">#</a> 其他</h2><ul><li><code>FOUC</code>（<code>Flash Of Unstyled Content</code>）。</li><li><code>preload</code>专注于为当前页面加载资源，而<code>prefetch</code>则专注于为下一个可能点击的页面加载资源。</li></ul>',11),h=[r];function o(l,t){return a(),d("div",null,h)}const s=e(i,[["render",o],["__file","知识点.html.vue"]]);export{s as default};
