import{_ as o,o as e,c,e as d}from"./app-M6OZmubj.js";const t="/skill-blog/img/0052.png",i={},n=d('<h1 id="基于cookie的认证与基于token的认证" tabindex="-1"><a class="header-anchor" href="#基于cookie的认证与基于token的认证" aria-hidden="true">#</a> 基于<code>cookie</code>的认证与基于<code>token</code>的认证</h1><p><img src="'+t+'" alt=""></p><p>二者最根本的区别是存储状态信息的位置。</p><p>基于<code>token</code>认证的服务器端会把登录状态信息编码后回传给浏览器，而基于<code>cookie</code>认证的状态信息还是保存在服务器端的会话中，但同时客户端<code>cookie</code>中会存储一个与会话对应的<code>id</code>。</p><p>所以通过这两种方式获取状态信息的时候就出现了区别。基于<code>cookie</code>认证的服务器端会在请求头部的<code>cookie</code>字段中获取<code>session</code>的<code>id</code>，然后找到对应的会话信息并校验。基于<code>token</code>认证的服务器端则会直接利用密钥信息对<code>token</code>进行解密和校验。</p><p>基于<code>cookie</code>认证的这种方式一般看作是有状态的，需要客户端和服务器端同时保存信息；基于<code>token</code>的方式只需要客户端保存信息，通常被看作是无状态的，可以减轻服务器端的存储压力，也适用于无<code>cookie</code>的情况，例如微信小程序。</p><p>建议优先选择基于<code>token</code>的认证方式，主要有以下几方面的原因：</p><ul><li><strong>无状态</strong>。基于<code>token</code>认证的服务器端只需要对数据进行编码，然后解密校验，不需要存储状态信息（服务器端的资源是很宝贵的，看看服务器和个人<code>PC</code>的价格对比就知道了），可以减轻服务器端的运行压力和开发压力。而从客户端来看，只需要存储好<code>token</code>信息，在对应请求头部添加<code>token</code>即可，工作量并不大。</li><li><strong>域问题</strong>。<code>cookie</code>的工作机制和域有关，如果域不同那么<code>cookie</code>将会失效。而<code>token</code>与域无关，完全不用考虑这个问题。</li><li><strong>性能问题</strong>。对客户端来说，由于无法改写<code>HttpOnly</code>下的<code>cookie</code>，同域下的所有请求头部都会带上<code>cookie</code>，而实际上并不是访问所有资源都需要，浪费了网络带宽。<code>token</code>则对域没有要求，客户端可自行决定是否在请求头部中添加<code>token</code>信息。再从服务器端角度出发，基于<code>cookie</code>认证的服务器端每次收到<code>cookie</code>中的会话<code>id</code>之后，可能需要在数据库中查询对应的信息，这无疑增加了处理时间和服务器的负担。<code>token</code>可直接解密获取信息，效率更高。</li><li><strong>通用性</strong>。和服务器端通信的可能不止是浏览器，也可能是其他设备，这些设备很可能不支持<code>cookie</code>，或者即使是浏览器也可能由于用户设置不使用<code>cookie</code>而导致失效，所以基于<code>token</code>认证的方案通用性更强。</li></ul><p>鉴于以上原因，基于<code>token</code>认证的方式正在被越来越多的服务器端所使用，例如我们经常看到可以使用微信或者<code>GitHub</code>账号来直接登录第三方的系统，这其中遵循的就是基于<code>token</code>认证的一套称之为<code>OAuth</code>的开放授权标准。</p>',9),k=[n];function s(_,r){return e(),c("div",null,k)}const p=o(i,[["render",s],["__file","基于cookie的认证与基于token的认证.html.vue"]]);export{p as default};
