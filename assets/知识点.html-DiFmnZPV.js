import{_ as c,r as a,o as r,c as i,a as e,b as n,d as t,e as d}from"./app-M6OZmubj.js";const l="/skill-blog/img/0107.jpg",h={},s=d('<h1 id="知识点" tabindex="-1"><a class="header-anchor" href="#知识点" aria-hidden="true">#</a> 知识点</h1><h2 id="什么是webpack" tabindex="-1"><a class="header-anchor" href="#什么是webpack" aria-hidden="true">#</a> 什么是<code>Webpack</code></h2><p><code>Webpack</code>是一个模块打包工具（<code>Module Bundler</code>，如<code>Browserify</code>或<code>Brunch</code>），而不是一个任务执行工具（<code>Task Runner</code>，如<code>Make</code>，<code>Grunt</code>或<code>Gulp</code>）。</p><p>任务执行工具用来自动化处理常见的开发任务，如<code>lint</code>（代码检测）、<code>build</code>（构建）、<code>test</code>（测试）。相比于模块打包工具，任务执行工具则聚焦在偏重上层的问题上面。</p><p>你仍然可以得益于这种用法：使用上层的工具，而将打包部分的问题留给<code>Webpack</code>。</p><h2 id="tree-shaking" tabindex="-1"><a class="header-anchor" href="#tree-shaking" aria-hidden="true">#</a> <code>tree shaking</code></h2><p><code>tree shaking</code>只能对<code>ES6 Module</code>生效。</p><p>如果我们在工程中使用了<code>babel-loader</code>，那么一定要通过配置来禁用它的模块依赖解析。因为如果由<code>babel-loader</code>来做依赖解析，<code>Webpack</code>接收到的就都是转化过的<code>CommonJS</code>形式的模块，无法进行<code>tree shaking</code>。</p><p><code>tree shaking</code>本身只是为死代码添加上标记，真正去除死代码是通过压缩工具来进行的。</p><h2 id="loader与plugin" tabindex="-1"><a class="header-anchor" href="#loader与plugin" aria-hidden="true">#</a> <code>loader</code>与<code>plugin</code></h2><p><code>loader</code>其实就是一个转换器，执行单纯的文件转换操作。</p><p><code>plugin</code>是一个扩展器，它丰富了<code>Webpack</code>本身，在<code>loader</code>中的操作执行结束后，<code>Webpack</code>进行打包时，<code>Webpack plugin</code>并不直接操作文件，而是基于事件工作机制，监听<code>Webpack</code>打包过程中的某些事件，见缝插针，修改打包结果。</p><h2 id="工作流程" tabindex="-1"><a class="header-anchor" href="#工作流程" aria-hidden="true">#</a> 工作流程</h2><p><img src="'+l+'" alt=""></p>',14),p={href:"https://juejin.cn/book/7115598540721618944/section/7118367034789855247",target:"_blank",rel:"noopener noreferrer"},u=d('<h2 id="同步和异步" tabindex="-1"><a class="header-anchor" href="#同步和异步" aria-hidden="true">#</a> 同步和异步</h2><p>同步：同步加载，一般为入口起点指定的所有模块及其依赖项。</p><p>异步：延迟加载，可能会出现在使用动态导入（dynamic import）或者<code>SplitChunksPlugin</code>时。</p><h2 id="按需加载" tabindex="-1"><a class="header-anchor" href="#按需加载" aria-hidden="true">#</a> 按需加载</h2><p>按需加载分为两种情况：</p><ul><li>我们的库要用到另一个库的功能，但只用到其中一小部分功能，如果将其全部打包过来，则会让打包体积变大，此时通过<code>treeshaking</code>功能可以自动屏蔽未被使用的功能。</li><li>要让使用我们库的项目能够按需加载。一个库如果不进行任何配置，那么现代打包工具是不会使用<code>treeshaking</code>功能对其进行优化的，因为打包工具无法知道一个库是否有副作用。如果我们的库没有副作用，则可以向<code>package.json</code>文件中添加<code>sideEffects</code>字段，这样打包工具就能够使用<code>treeshaking</code>功能进行优化了。</li></ul><h2 id="其他" tabindex="-1"><a class="header-anchor" href="#其他" aria-hidden="true">#</a> 其他</h2><ul><li>一般来说，在生产环境下，我们希望样式存在于<code>CSS</code>文件中而不是<code>style</code>标签中，因为文件更有利于客户端进行缓存。</li><li><code>Webpack</code>的运行时指的是初始化环境的代码，如创建模块缓存对象、声明模块加载函数等。</li><li>当模块数量过多、资源体积过大时，可以把一些暂时用不到的模块延迟加载（即资源异步加载）。</li><li><code>ES6 Module</code>中要求<code>import</code>必须出现在代码的顶层作用域，而<code>Webpack</code>的<code>import</code>函数可以在任何我们希望的时候调用。</li><li><code>emitted</code>：文件被输出。</li><li>通过打印完整的<code>Config</code>调试</li></ul>',8);function k(b,_){const o=a("ExternalLinkIcon");return r(),i("div",null,[s,e("p",null,[e("a",p,[n("参考资料"),t(o)])]),u])}const f=c(h,[["render",k],["__file","知识点.html.vue"]]);export{f as default};
