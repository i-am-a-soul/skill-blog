import{_ as e,o as d,c as o,e as c}from"./app-M6OZmubj.js";const a={},r=c('<h1 id="抽象原则" tabindex="-1"><a class="header-anchor" href="#抽象原则" aria-hidden="true">#</a> 抽象原则</h1><h2 id="第一原则-dry" tabindex="-1"><a class="header-anchor" href="#第一原则-dry" aria-hidden="true">#</a> 第一原则：<code>DRY</code></h2><p>最著名的抽象原则应该是“<code>DRY</code>（<code>Don&#39;t Repeat Yourself</code>）”，这个原则主张项目中的每一段代码都必须是唯一的、明确的，不能含有任何重复代码，认为任何重复代码都应该被抽象出来进行复用。</p><p>遵循<code>DRY</code>原则不仅可以减少代码量，同时也会给代码维护带来很大的好处，可以避免多处修改。</p><p>但是这种一刀切的做法在某些情况下显得有些过于理想化，所以如果完全照搬这个原则有时会增加代码复杂度和开发工作量。这个时候我们需要别的原则来“修正”它。</p><h2 id="第二原则-yagni" tabindex="-1"><a class="header-anchor" href="#第二原则-yagni" aria-hidden="true">#</a> 第二原则：<code>YAGNI</code></h2><p>极限编程中提出了另一个原则<code>YAGNI</code>（<code>You aren&#39;t gonna need it</code>），翻译过来的意思就是直到你确实需要某个功能时才添加它。因为很多时候开发者自以为有用的功能，可能是用不到的。因此，这种只关注核心功能的方式，可以大大加快开发速度，同时代码越少一般<code>bug</code>也越少。<code>YAGNI</code>原则和<code>DRY</code>原则有时候是冲突的，前者追求“抽象化”，要求找到通用的解决方法；后者追求“快和省”，意味着不要把精力放在抽象化上面，因为很可能“你不会需要它”。所以比较推荐的方式是优先考虑<code>YAGNI</code>原则，然后结合<code>DRY</code>原则。</p><h2 id="第三原则-the-rule-of-three" tabindex="-1"><a class="header-anchor" href="#第三原则-the-rule-of-three" aria-hidden="true">#</a> 第三原则：<code>The Rule of Three</code></h2><p>但是很快问题又来了，<code>YAGNI</code>原则该怎么实践？怎么判断编写的代码是必需的？</p><p>这时候我们引入第三个原则：<code>The Rule of Three</code>。</p><p>理解起来很简单，就是当一段代码逻辑出现第三次的时候再去抽象出它进行公用。</p>',11),h=[r];function t(n,i){return d(),o("div",null,h)}const _=e(a,[["render",t],["__file","抽象原则.html.vue"]]);export{_ as default};
