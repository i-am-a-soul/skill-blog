import{_ as n,o as s,c as a,e}from"./app-M6OZmubj.js";const t="/skill-blog/img/0104.jpg",p={},o=e(`<h1 id="类型和接口" tabindex="-1"><a class="header-anchor" href="#类型和接口" aria-hidden="true">#</a> 类型和接口</h1><p>第一，类型别名更为通用，右边可以是任何类型，包括类型表达式（类型，外加<code>&amp;</code>或<code>|</code>等类型运算符）；而在接口声明中，右边必须为结构。例如，下述类型别名不能使用接口重写：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token operator">=</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name"><span class="token constant">B</span></span> <span class="token operator">=</span> <span class="token constant">A</span> <span class="token operator">|</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>第二个区别是，扩展接口时，<code>TypeScript</code>将检查扩展的接口是否可赋值给被扩展的接口。例如：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token punctuation">{</span>
    <span class="token function">good</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span>
    <span class="token function">bad</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name"><span class="token constant">B</span></span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token punctuation">{</span>
    <span class="token function">good</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span>
    <span class="token function">bad</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token comment">// Error TS2430: Interface &#39;B&#39; incorrectly extends interface &#39;A&#39;. Type &#39;number&#39; is not assignable to type &#39;string&#39;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而使用交集类型时则不会出现这种问题。如果把前例中的接口换成类型别名，把<code>extends</code>换成交集运算符（<code>&amp;</code>），<code>TypeScript</code>将尽自己所能，把扩展和被扩展的类型组合在一起，最终的结果是重载<code>bad</code>的签名，而不会抛出编译时错误。</p><p>建模对象类型的继承时，<code>TypeScript</code>对接口所做的可赋值性检查是捕获错误的有力工具。</p><p>第三个区别是，同一作用域中的多个同名接口将自动合并；同一作用域中的多个同名类型别名将导致编译时错误，这个特性称为声明合并。</p><p><img src="`+t+'" alt=""></p>',9),c=[o];function i(l,r){return s(),a("div",null,c)}const u=n(p,[["render",i],["__file","类型和接口.html.vue"]]);export{u as default};
