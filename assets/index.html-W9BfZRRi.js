import{_ as e,o as d,c,e as o}from"./app-M6OZmubj.js";const a="/skill-blog/img/0028.png",i="/skill-blog/img/0126.jpg",r="/skill-blog/img/0127.jpg",s="/skill-blog/img/0029.png",l="/skill-blog/img/0124.jpg",t="/skill-blog/img/0125.jpg",n="/skill-blog/img/0128.jpg",h={},p=o('<h1 id="知识点" tabindex="-1"><a class="header-anchor" href="#知识点" aria-hidden="true">#</a> 知识点</h1><h2 id="主流浏览器内核" tabindex="-1"><a class="header-anchor" href="#主流浏览器内核" aria-hidden="true">#</a> 主流浏览器内核</h2><p><img src="'+a+'" alt=""></p><p><img src="'+i+'" alt=""></p><h2 id="渲染页面的大致流程" tabindex="-1"><a class="header-anchor" href="#渲染页面的大致流程" aria-hidden="true">#</a> 渲染页面的大致流程</h2><ol><li>解析<code>HTML</code>标签并生成<code>DOM</code>树</li><li>解析<code>CSS</code>规则并生成<code>CSSOM</code>树</li><li>将<code>DOM</code>树与<code>CSSOM</code>树合并成一个渲染树</li><li>根据渲染树来进行<strong>布局</strong></li><li>对渲染树上的节点进行<strong>绘制</strong></li></ol><h2 id="js引擎和渲染引擎" tabindex="-1"><a class="header-anchor" href="#js引擎和渲染引擎" aria-hidden="true">#</a> <code>JS</code>引擎和渲染引擎</h2><p><img src="'+r+'" alt=""></p><h2 id="defer与async" tabindex="-1"><a class="header-anchor" href="#defer与async" aria-hidden="true">#</a> <code>defer</code>与<code>async</code></h2><p><code>script</code>标签中的<code>defer</code>和<code>async</code>属性可以让浏览器的工作顺序发生一些变化。</p><ul><li><code>defer</code>属性可以将执行<code>js</code>的操作延后，一直等到<code>HTML</code>解析完成再执行。</li><li><code>async</code>属性可以并发请求获取<code>js</code>，但是执行<code>js</code>的时候仍然会阻塞渲染引擎。</li></ul><p><img src="'+s+'" alt=""></p><h2 id="浏览器架构对比" tabindex="-1"><a class="header-anchor" href="#浏览器架构对比" aria-hidden="true">#</a> 浏览器架构对比</h2><p><img src="'+l+'" alt=""></p><h2 id="多进程架构下的分工" tabindex="-1"><a class="header-anchor" href="#多进程架构下的分工" aria-hidden="true">#</a> 多进程架构下的分工</h2><p><img src="'+t+'" alt=""></p><h2 id="渲染进程" tabindex="-1"><a class="header-anchor" href="#渲染进程" aria-hidden="true">#</a> 渲染进程</h2><p><img src="'+n+'" alt=""></p><h2 id="其他" tabindex="-1"><a class="header-anchor" href="#其他" aria-hidden="true">#</a> 其他</h2><ul><li><code>JavaScript</code>引擎和渲染引擎这两个线程都可以操作<code>DOM</code>，这样的话就很容易会出现一些问题，为了降低浏览器的复杂度，设计了一种机制——在某一时刻只有一个线程可以操作<code>DOM</code>，也就是说渲染引擎和<code>JavaScript</code>引擎会相互阻塞。</li><li>在<code>HTTP/1.1</code>协议中，为了避免浏览器过度消耗服务器端资源，所以限制了浏览器针对同一域名的并发请求数量，不同浏览器的限制数量在<code>4-8</code>不等，超过限制数量的请求将会被阻塞，延迟发送。</li></ul>',20),g=[p];function _(m,f){return d(),c("div",null,g)}const b=e(h,[["render",_],["__file","index.html.vue"]]);export{b as default};
