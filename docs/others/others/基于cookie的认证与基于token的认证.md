# 基于`cookie`的认证与基于`token`的认证

二者最根本的区别是存储状态信息的位置。

基于`token`认证的服务器端会把登录状态信息编码后回传给浏览器，而基于`cookie`认证的状态信息还是保存在服务器端的会话中，但同时客户端`cookie`中会存储一个与会话对应的`id`。

所以通过这两种方式获取状态信息的时候就出现了区别。基于`cookie`认证的服务器端会在请求头部的`cookie`字段中获取`session`的`id`，然后找到对应的会话信息并校验。基于`token`认证的服务器端则会直接利用密钥信息对`token`进行解密和校验。

基于`cookie`认证的这种方式一般看作是有状态的，需要客户端和服务器端同时保存信息；基于`token`的方式只需要客户端保存信息，通常被看作是无状态的，可以减轻服务器端的存储压力，也适用于无`cookie`的情况，例如微信小程序。

建议优先选择基于`token`的认证方式，主要有以下几方面的原因：

- **无状态**。基于`token`认证的服务器端只需要对数据进行编码，然后解密校验，不需要存储状态信息（服务器端的资源是很宝贵的，看看服务器和个人`PC`的价格对比就知道了），可以减轻服务器端的运行压力和开发压力。而从客户端来看，只需要存储好`token`信息，在对应请求头部添加`token`即可，工作量并不大。
- **域问题**。`cookie`的工作机制和域有关，如果域不同那么`cookie`将会失效。而`token`与域无关，完全不用考虑这个问题。
- **性能问题**。对客户端来说，由于无法改写`HttpOnly`下的`cookie`，同域下的所有请求头部都会带上`cookie`，而实际上并不是访问所有资源都需要，浪费了网络带宽。`token`则对域没有要求，客户端可自行决定是否在请求头部中添加`token`信息。再从服务器端角度出发，基于`cookie`认证的服务器端每次收到`cookie`中的会话`id`之后，可能需要在数据库中查询对应的信息，这无疑增加了处理时间和服务器的负担。`token`可直接解密获取信息，效率更高。
- **通用性**。和服务器端通信的可能不止是浏览器，也可能是其他设备，这些设备很可能不支持`cookie`，或者即使是浏览器也可能由于用户设置不使用`cookie`而导致失效，所以基于`token`认证的方案通用性更强。

鉴于以上原因，基于`token`认证的方式正在被越来越多的服务器端所使用，例如我们经常看到可以使用微信或者`GitHub`账号来直接登录第三方的系统，这其中遵循的就是基于`token`认证的一套称之为`OAuth`的开放授权标准。

