# 跨域

## 什么是跨域

[浏览器的同源策略](https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy)。

例子：

![](/img/0019.png)

## `JSONP`（`JSON with Padding`）

`JSONP`算是一种“曲线救国”的方式，虽然`AJAX`请求必须同源，但是`HTML`上通过标签请求的资源文件，比如`CSS`样式文件、`PNG`图片文件、`JS`脚本文件却是可以不同源的（所以很多网站会使用`CDN`服务器将这些资源缓存起来，从而减少用于请求这些文件的时间）。这种方法就是创建一个`script`，浏览器识别标签后会向指定的网址发送`GET`请求，获得脚本内容并执行，这个脚本内部通常会声明一个函数或变量以供调用。示例如下：

```html
<script>
    // 请求脚本后的回调函数
    var getData = function (data) {
        console.log(data)
    }

    // 请求地址
    var url = 'http://xxx/jsonp.js?id=1&callback=getData'

    // 创建 script 标签
    var script = document.createElement('script')
    script.setAttribute('src', url)
    document.getElementsByTagName('body')[0].appendChild(script)
</script>

// jsonp.js
(function () {
    getData(1234)
}())
```

页面通过`script`标签向另一个服务器端请求数据时，也带上了参数`id`和`callback`，服务器端据此生成对应的脚本文件（将数据填充入脚本中）并调用回调函数。这样就完成一次数据的请求操作。但是缺点也很明显：只能通过地址栏提交一些简单的参数，而且这种显式传递方式也非常不安全，通常也需要服务器端支持生成对应的文件。

缺点：

- 只支持`GET`方法
- 发送的不是`xhr`请求

## `CORS`（`Cross-Origin Resource Sharing`）

虽然为了安全起见，默认采用同源策略，但是`W3C`还是开了个后门叫作“跨域资源共享”。

这种跨域方式要求前后端同时支持，并且需要在返回头部字段做修改，操作起来相对复杂。这种跨域方式将请求类型分为两种——简单请求和非简单请求，针对不同情况需要分别处理。

### 简单请求

需要同时满足两个条件：

- 请求方法为`GET`、`HEAD`、`POST`之一；
- 请求头部只能包含`Accept`、`Accept-Language`、`Content-Language`、`Content-Type`（值只能为`text/plain`、`multipart/form-data`、`application/x-www-form-urlencoded`之一）、`DPR`、`Downlink`、`Save-Data`、`Viewport-Width`、`Width`这些字段。

浏览器发送请求的时候会在头部的`Origin`字段带上本次请求的“源”信息（协议`+`域名`+`端口），服务器端会返回能够接受的源，“`*`”表示可以接受任意源的请求。

`MDN`上的一张图显示了一次请求中浏览器和服务器端的交互过程，如图所示。

![](/img/0025.png)

### 非简单请求

非简单请求在发送之前，需要先使用`OPTIONS`方法发起一个预检请求到服务器端，以获知服务器端是否允许该实际请求。预检请求的使用，可以避免跨域请求对服务器端的用户数据产生未预期的影响。

只有得到服务器端确认允许请求之后才可以发送请求。

依旧借用`MDN`上的一张图显示一次非简单请求中浏览器和服务器端的交互过程。

![](/img/0026.png)

参考资料：

- [跨域资源共享 CORS 详解](http://www.ruanyifeng.com/blog/2016/04/cors.html)
- [跨源资源共享（CORS）](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS)

## 反向代理

反向代理是最常用也是最推荐的方式，那么什么是反向代理呢？

简言之，反向代理就是代理服务器负责响应浏览器（实际上也有可能是其他客户端，这里为了叙述方便，我们只考虑浏览器作为客户端的情况）发出的请求，将请求区分成两类：一类是资源文件，比如`JS`、`HTML`、`CSS`、`PNG`，直接读取文件或缓存并返回；其他请求都直接转发给后端服务器，然后接收后端服务器返回的结果并返回给浏览器。

反向代理发送请求和响应请求的流程如图所示。

![](/img/0027.png)

**反向代理利用的原理就是通过代理服务器把浏览器与服务器端之间的通信转化为服务器端与服务器端之间的通信，而服务器端之间是没有同源策略和跨域之说的**。当然整个流程需要对代理服务器进行配置，配置对应的转发规则，比如根据请求后缀或路径转发对应的请求等。

生产环境中最常用的反向代理服务器当属俄罗斯开发的`Nginx`，它使用简单（一条命令即可启动）而且支持丰富的配置（转发、负载均衡、压缩等）。截取一段配置文件进行举例说明：

```
# 配置一个服务器端
server {
    # 端口为 2017
    listen 2017;

    # 配置根路径，资源文件请求将会在此目录下查找
    root /usr/share/nginx/html;

    # 网站根路径请求返回的文件
    index index.html;

    # 规则，对以 /api 开头的请求进行操作
    location /api {
        # 转发服务器端地址
        proxy_pass http://localhost:2018;
    }
}
```

在这个实例中，默认请求都会在磁盘上`/usr/share/nginx/html`目录下查找对应的文件，如果请求以`/api`开头，则会转发到`http://localhost:2018`。这样我们在浏览器端发送`AJAX`请求的时候，只需要加上`/api`前缀即可。

这种跨域方式之所以不叫“代理”而称为“反向代理”，那是因为还存在“正向代理”。刚才我们讲到反向代理的转发规则对于浏览器客户端而言是不可知的，用户不知道真正的后端地址，而正向代理的转发规则是由客户端进行指定的，服务器端不知道真实的客户端是谁，这种方式即常用的`VPN`。

开发中就可以通过正向代理的方式实现跨域。例如`Webpack`构建的`webpack-dev-server`插件就支持代理的配置：

```js
devServer: {
    // 代理配置
    proxy: {
        // 代理规则，以 /api/ 开头的请求将会进行转发
        '/api/*': {
            // 转发地址
            target: 'http://localhost:5000'
        }
    }
}
```

通过代理的配置可以直接指向任意的服务器地址，方便开发和调试。

讲完正向代理再回到反向代理，反向代理不光可以解决跨域问题，还可以用于以下方面：

- 保障服务器安全，因为隐藏了真实的服务器端地址；
- 负载均衡，通过转发策略向多个服务器端进行请求转发；
- 缓存静态内容。

