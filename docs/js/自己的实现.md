# 自己的实现

## `apply`



## `bind`



## `Promise`

### `Promise`

```js
function Promise (executor) {
    this.status = 'pending'
    this.data = null
    this.err = null
    this.onFulfilledFuncArr = []
    this.onRejectedFuncArr = []

    const resolve = data => {
        if (data instanceof Promise) {
            data.then(resolve, reject)
            return
        }

        setTimeout(() => {
            if (this.status === 'pending') {
                this.status = 'fulfilled'
                this.data = data
                this.onFulfilledFuncArr.forEach(func => {
                    func()
                })
            }
        })
    }
    const reject = err => {
        setTimeout(() => {
            if (this.status === 'pending') {
                this.status = 'rejected'
                this.err = err
                this.onRejectedFuncArr.forEach(func => {
                    func()
                })
            }
        })
    }
    
    try {
        executor(resolve, reject)
    } catch (err) {
        reject(err)
    }
}
```

### `Promise.prototype.then`

```js
Promise.prototype.then = function (onfulfilled, onrejected) {
    if (typeof onfulfilled !== 'function') { onfulfilled = data => data }
    if (typeof onrejected !== 'function') { onrejected = err => { throw err } }

    if (this.status == 'fulfilled') {
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                try {
                    const res = onfulfilled(this.data)
                    resolve(res)
                } catch (err) {
                    reject(err)
                }
            })
        })
    } else if (this.status == 'rejected') {
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                try {
                    const res = onrejected(this.err)
                    resolve(res)
                } catch (err) {
                    reject(err)
                }
            })
        })
    } else {
        return new Promise((resolve, reject) => {
            this.onFulfilledFuncArr.push(() => {
                try {
                    const res = onfulfilled(this.data)
                    resolve(res)
                } catch (err) {
                    reject(err)
                }
            })
            this.onRejectedFuncArr.push(() => {
                try {
                    const res = onrejected(this.err)
                    resolve(res)
                } catch (err) {
                    reject(err)
                }
            })
        })
    }
}
```

### `Promise.prototype.catch`

```js
Promise.prototype.catch = function (onrejected) {
    return this.then(null, onrejected)
}
```

### `Promise.resolve`

```js
Promise.resolve = function (data) {
    return new Promise((resolve, reject) => {
        resolve(data)
    })
}
```

### `Promise.reject`

```js
Promise.reject = function (err) {
    return new Promise((resolve, reject) => {
        reject(err)
    })
}
```

### `Promise.all`

```js
Promise.all = function (promiseArray) {
    if (!Array.isArray(promiseArray)) {
        throw new TypeError('promiseArray should be an array')
    }

    return new Promise((resolve, reject) => {
        try {
            const res = []
            promiseArray.forEach(p => {
                p.then(data => {
                    if (res.push(data) === promiseArray.length) {
                        resolve(res)
                    }
                }, reject)
            })
        } catch (err) {
            reject(err)
        }
    })
}
```

### `Promise.race`

```js
Promise.race = function (promiseArray) {
    if (!Array.isArray(promiseArray)) {
        throw new TypeError('promiseArray should be an array')
    }

    return new Promise((resolve, reject) => {
        try {
            promiseArray.forEach(p => {
                p.then(resolve, reject)
            })
        } catch (err) {
            reject(err)
        }
    })
}
```

## `new`

```js
function newFunc (...args) {
    const constructor = args.shift(),
        obj = Object.create(constructor.prototype),
        res = constructor.apply(obj, args)
    
    return (typeof res === 'object' && res !== null) ? res : obj;
}

function Person (name) {
    this.name = name
}

const p = newFunc(Person, 'Lucas')
console.log(p)
```

